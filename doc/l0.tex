\documentclass[oneside]{memoir}
\usepackage{alltt}
\usepackage{amsmath}

\title{The L0 Programming Language}
\date{\today}
\author{Troels Henriksen (athas@sigkill.dk)}

% Remove chapter numbering, as we only use one chapter in this
% document.
\counterwithout{section}{chapter}

\newcommand\boolt[0]{\texttt{bool}}
\newcommand\realt[0]{\texttt{real}}
\newcommand\chart[0]{\texttt{char}}
\newcommand\intt[0]{\texttt{int}}
\newcommand\aliases[1]{\textrm{aliases}(#1)}
\renewcommand\tilde[0]{{\raise.17ex\hbox{$\scriptstyle\sim$}}}

\begin{document}

\maketitle

\section{Introduction}

This document has been prepared as an informal overview of the L0
language.  In time, we hope to develop it into a formal specification,
with accompanying proofs of correctness, but for now, words will have
to suffice where formulae would be ideal.

L0 is an eagerly evaluated, purely functional language with built-in
arrays and second-order array combinators, which is intended for use
as an \emph{intermediate language} (sometimes called a \emph{core
  language}) with a focus towards efficient execution on vector
hardware (GPUs).  While L0 is not designed to be a pleasant
programming experience for humans, it does have a textual syntax to
facilitate the writing of benchmark programs.

Section \ref{sec:l0-overview} gives a cursory tour of the L0 language.

Section \ref{sec:l0-reference} proceeds with a syntax-oriented
description of every language construct in L0.

Section \ref{sec:l0-uniqueness-types} describes the \emph{uniqueness
  types} of L0; a type system feature that permits in-place
modification of arrays as long as it can be proven that referential
transparency is upheld.

\section{Language overview}
\label{sec:l0-overview}

The syntax of L0 is heavily inspired by Haskell and Standard ML.  An
identifier stats with an letter, followed by any number of letters,
digits and underscores.  Numeric constants use the same notation as
Haskell, except that we use tilde (\tilde{}) for unary minus.  String
and character literals literals use Haskell syntax (which is very
similar to C), including all escape characters.  Comments are
indicated with \texttt{//} and span to end of line.

An L0 program consists of a sequence of \emph{function definitions},
of the following form.

\begin{alltt}
  fun \textit{return-type} \textit{name}(\textit{params...}) = \textit{body}
\end{alltt}

A function must declare both its return type and the types of all
parameters.  All functions (except for inline anonymous functions; see
below) are defined globally.  L0 does not use type inference.
Symbolic constants are not supported, although 0-ary functions can be
defined.  As a concrete example, here is the recursive definition of
the factorial function in L0.
\begin{alltt}
  fun int fact(int n) =
    if n = 0 then 1
             else n * fact(n-1)
\end{alltt}
Indentation has no syntactical significance in L0, but recommended for
readability.

The syntax for tuple types is identical to that of Haskell, so
\texttt{(int, real)} is a pair of an integer and a floating-point
number.  Single-element tuples are not valid.  Arrays are written as
the element type surrounded by brackets, meaning that \texttt{[int]}
is a one-dimensional array of integers, and \texttt{[[[(int, real)]]]}
is a three-dimensional array of tuples of integers and floats.  An
array is written as a sequence of elements enclosed by braces.
\begin{alltt}
  \{1, 2, 3\}       // Array of type [int].
  \{\{1\}, \{2\}, \{3\}\} // Array of type [[int]].
\end{alltt}
All arrays must be \emph{regular} (often termed \emph{full}) - for
example, all rows of a two-dimensional array must have the same number
of elements.
\begin{alltt}
  \{\{1, 2\}, \{3\}\} // This is an error.
\end{alltt}
Arrays are indexed using common \texttt{a[i1, i2, i3...]}
Fortran-style notation.  An indexing is said to be \textit{full} if
the number of given indexes is equal to the dimensionality of the
array.

A \texttt{let}-expression can be used to refer to the result of a
subexpression:
\begin{alltt}
  let z = x + y in ...
\end{alltt}
Only a single binding is permitted for each \texttt{let}.

Two-way \texttt{if-then-else} is the only branching construct in L0.
Pattern matching is supported in a limited way for taking apart
tuples, but this can only be done in \texttt{let}-bindings, and not
directly in a function argument list.  Specifically, the following
function definition is not valid.
\begin{alltt}
  fun int sumpair((int, int) (x, y)) = x + y // WRONG!
\end{alltt}
Instead, we must use a let-binding explicitly, as follows.
\begin{alltt}
  fun int sumpair((int, int) t) =
    let (x,y) = t in x + y
\end{alltt}
Pattern-matching in a binding is the only way to access the components
of a tuple.

Function calls are written as the function name followed by the
arguments enclosed in parentheses.  The built-in second-order array
combinators (\emph{SOAC}s) are written much like a function call,
except that one or more of a SOACs arguments may be a \emph{function
  reference}.  A function reference is an anonymous function
(``lambda'') or the name of some function, possibly with curried
arguments.  As an example, let us consider the following function for
adding two integers.
\begin{alltt}
fun int sum(int x, int y) = x + y
\end{alltt}
We may use this in conjunction with the \texttt{map} SOAC to add two
to every element of an array \texttt{a}.
\begin{alltt}
map(sum (2), a)
\end{alltt}
This is semantically equivalent to
\begin{alltt}
map(fn int (int x) => sum(2, x), a)
\end{alltt}
which also demonstrates the syntax for anonymous functions.  Note that
while some language constructs look like functions (\texttt{size}, for
example), they are not, and cannot be used as a function reference.

An operator can be used as the function argument of a SOAC by
prefixing it with \texttt{op}.  For example, to negate every number in
the array \texttt{a}, we would write \texttt{map(op \tilde{}, a)}.
This can also be combined with currying: \texttt{map(op + (2), a)}.

Except for the arithmetic operators, which accept both \realt{}s
and \intt{}s, every construct is L0 is fully monomorphic.  Every
user-defined function must be first-order; higher-order arguments can
only be used in direct calls of SOACs.

L0 has a built-in syntax for expressing certain tail-recursive
functions.  Consider the following tail-recursive formulation of a
function for computing the Fibonacci numbers.
\begin{alltt}
  fun int fib(int n) = fibhelper(1,1,n)

  fun int fibhelper(int x, int y, int n) =
    if n = 1 then x else fibhelper(y, x+y, n-1)
\end{alltt}
We can rewrite this using the \texttt{loop} construct.
\begin{alltt}
  fun int fib(int n) =
    loop ((x, y) = (1,1)) = for i < n do
                              (y, x+y)
    in x
\end{alltt}
The semantics of this is precisely as in the tail-recursive function
formulation.  In general, a loop
\begin{alltt}
  loop (\emph{pat} = \emph{initial}) = for \emph{i} < \emph{bound} do \emph{loopbody}
  in \emph{body}
\end{alltt}
has the following semantics:

\begin{enumerate}
  \item Bind \textit{pat} to the initial values given in \textit{initial}.
  \item While $\textit{i} < \textit{bound}$, evaluate \textit{loopbody},
    rebinding \textit{pat} to be the value returned by the body.
  \item Evaluate \textit{body} with \textit{pat} bound to its final
    value.
\end{enumerate}
The purpose of \texttt{loop} is partly to render some sequential
computations slightly more convenient, partly to express certain loop
optimisations in the compiler.  Semantically, it is completely
equivalent to the corresponding tail-recursive function.

General modification of array elements is done using the
\emph{let-with} construct.  In its most general form, it looks as
follows.
\begin{alltt}
  let \textit{dest} = \textit{src} with [\textit{indexes}] <- \textit{value}
  in \textit{body}
\end{alltt}
This evaluates \textit{body} with \textit{dest} bound to the value of
\textit{src}, except that the element(s) at the position given by
\textit{indexes} take on the new value \textit{value}.\footnote{Yes,
  this is the \emph{third} binding construct in the language, ignoring
  function abstraction!}  The given indexes need not be complete, but
in that case, \textit{value} must be an array of the proper size.  As
an example, here's how we could replace an entire row of an
$n\times3$ array.
\begin{alltt}
  let b = a with [3] <- {1,2,3} in b
\end{alltt}
Whenever $\textit{dest} = \textit{src}$, we can write
\begin{alltt}
  let \textit{dest}[\textit{indexes}] = \textit{value} in \textit{body}
\end{alltt}
as a shortcut.  Let-with has some unusual restrictions to permit
in-place modification of the \textit{src} array, as described in
section \ref{sec:l0-uniqueness-types}.

\section{Language reference}
\label{sec:l0-reference}

The builtin types in L0 are \intt{}, \realt{}, \boolt{} and \chart{}, as
well as their combination in tuples and arrays.

The following list describes every syntactical language construct in
the language.

\begin{description}
  \item[\textit{constant}]\hfill\\
    Evaluates to itself.

  \item[\textit{var}]\hfill\\
    Evaluates to its value in the environment.

  \item[\texttt{\textit{x} \textbf{arithop} \textit{y}}] \hfill\\
    Evaluate the binary operator on its operands, which must both be
    of either type \intt{} or \realt.  The following operators are
    supported: \texttt{+}, \texttt{*}, \texttt{-}, \texttt{/},
    \texttt{\%}, \texttt{=}, \texttt{<}, \texttt{<=}, \texttt{pow}.

  \item[\texttt{\textit{x} \textbf{bitop} \textit{y}}] \hfill\\
    Evaluate the binary operator on its operands, which must both be
    of type \intt.  The following operators are supported:
    \texttt{\^}, \texttt{\&}, \texttt{|}, \texttt{>>}, \texttt{<<}.

  \item[\texttt{\textit{x} \&\& \textit{y}}]\hfill\\
    Short-circuiting conjunction, both operands must be of type \boolt.

  \item[\texttt{\textit{x} || \textit{y}}]\hfill\\
    Short-circuiting disjunction, both operands mus tbe of type \boolt.

  \item[\texttt{not \textit{x}}]\hfill\\
    Logical negation of \textit{x}, which must be of type \boolt.

  \item[\texttt{\tilde \textit{x}}]\hfill\\
    Numerical negation of \textit{x}, which must be of type \realt{} or \intt.

  \item[\texttt{a[i]}]\hfill\\
    Return the element at the given position in the array.  The index
    may be a comma-separated list of indexes.

  \item[\texttt{map(\textit{f}, \textit{a})}]\hfill\\
    Apply \textit{f} to every element of \textit{a} and return the resulting array.

  \item[\texttt{reduce(\textit{f}, \textit{x}, \textit{a})}]\hfill\\
    Left-reduction with \textit{f} across the elements of \textit{a},
    with \textit{x} as the initial value.  \textit{f} must be
    associative, as the evaluation order is not otherwise specified.

  \item[\texttt{scan(\textit{f}, \textit{x}, \textit{a})}]\hfill\\
    Inclusive prefix-scan.

  \item[\texttt{filter(\textit{f}, \textit{a})}]\hfill\\
    Remove all those elements of \textit{a} that do not satisfy the
    predicate \textit{f}.

  \item[\texttt{mapall(\textit{f}, \textit{a})}]\hfill\\
    Apply \textit{f} to every \emph{basic} element of \textit{a},
    returnin an array of the same shape.

  \item[\texttt{redomap(\textit{g}, \textit{f}, \textit{x}, \textit{a})}]\hfill\\
    Equivalent to \texttt{reduce(\textit{g}, \textit{n}, map(\textit{f}, \textit{a}))}.

  \item[\texttt{iota(\textit{n})}]\hfill\\
    An array of the integers from $0$ to \textit{n}.

  \item[\texttt{replicate(\textit{n}, \textit{a})}]\hfill\\
    An array consisting of \textit{n} copies of \textit{a}.

  \item[\texttt{size(\textit{a})}]\hfill\\
    The number of rows in the given array.

  \item[\texttt{split(\textit{n}, \textit{a})}]\hfill\\
    Partitions the given array into two disjoint arrays
    \texttt{\textit{a}[$0\ldots{}n$]}, \texttt{\textit{a}[$n+1\ldots{}$]}, as a tuple.

  \item[\texttt{concat(\textit{a}, \textit{b})}]\hfill\\
    Concatenate the rows/elements of one array with another.  The
    shape of the two arrays must be identical in all but the first
    dimensionel.

  \item[\texttt{copy(\textit{x})}]\hfill\\
    Return a deep copy of the argument.  Semantically, this is just
    the identiti function, bit it has special semantics related to
    uniqueness types as described in section
    \ref{sec:l0-uniqueness-types}.

  \item[\texttt{reshape((\textit{dim}$_{1}$, \ldots, \textit{dim}$_{n}$), a)}]\hfill\\
    Reshape the elements of the given array into the specified shape.
    The number of elements in \textit{a} must be equal to
    $\texttt{dim}_{1}\times\ldots\times\texttt{dim}_{n}$.

  \item[\texttt{\textit{transpose}(a)}]\hfill\\
    Return the transpose of \textit{a}.

  \item[\texttt{let \textit{pat} = \textit{e} in \textit{body}}]\hfill\\
    While evaluating \textit{body}, bind the names mentioned in
    \textit{pat} to the components in the corresponding positions of
    the value of \textit{e}.

  \item[\texttt{let \textit{dest} = \textit{src} with [\textit{index}] <- \textit{v} in \textit{body}}] \hfill \\
    Evaluate \textit{body} with \textit{dest} bound to the value of
    \textit{src}, except that the element(s) at the position given by
    the index take on the value of \textit{v}.  The given index need
    not be complete, but in that case, the value of \textit{v} must be
    an array of the proper size.

  \item{\texttt{if \textit{c} then \textit{a} else \textit{b}}}\hfill\\
    If \textit{c} evaluates to \textit{True}, evaluate \textit{a},
    else evaluate \textit{b}.

  \item{\texttt{loop (\textit{pat} = \textit{initial}) = for \textit{i} < \textit{bound} do \textit{loopbody} in \textit{body}}}
    \begin{enumerate}
    \item Bind \textit{pat} to the initial values given in \textit{initial}.
    \item While $\textit{i} < \textit{bound}$, evaluate \textit{loopbody},
      rebinding \textit{pat} to be the value returned by the body.
    \item Evaluate \textit{body} with \textit{pat} bound to its final
      value.
    \end{enumerate}

\end{description}

\subsection{Tuple shimming}

In a SOAC, if the given function expects $n$ arguments of types
\texttt{t$_{1}$,\ldots,{}t$_{n}$}, but the SOAC will call the function
with a single argument of type \texttt{(t$_{1}$*\ldots{}*t$_{n}$)}
(that is, a tuple), the L0 compiler will automatically generate an
anonymous unwrapping function in such a way that it still works.  This
allows the following expression to type-check (and run):

\begin{alltt}
  map(op +, zip(as, bs))
\end{alltt}

Without the above transformation, you would get an error, as
\texttt{op +} is a function that takes two arguments, but is passed a
tuple by \texttt{map}.

This eliminates the need for a dedicated \texttt{zipWith} construct.

\subsection{Arrays of tuples}

Arrays of tuples are in a sense merely syntactic sugar for tuples of
arrays.  The type \texttt{[(int, real)]} is transformed to
\texttt{([int], [real])} during the compilation process, and all code
interacting with arrays of tuples is likewise transformed.  In most
cases, this is fully transparent, but there are edge cases where the
transformation is not trivially an isomorphism.

Consider the type \texttt{[([int], [real])]}, which is transformed
into \texttt{([[int]], [[real]])}.  These two types are not
isomorphic, as the latter has more stringent demands as to the
fullness of arrays.  For example, \texttt{{({1}, {1.0}), ([2,3],
    {2.0})}} is a value of the former, but the corresponding
transformed value, \texttt{({{1}, {2, 3}}, {{1.0}, {2.0}})} is not a
full array.  Hence, when determining whether a program generates full
arrays, we must hence look at the \textit{transformed} values - in a
sence, the fullness requirement ``transcends'' the tuples.

\section{Uniqueness types}
\label{sec:l0-uniqueness-types}

The L0 type system supports the notion of \emph{uniqueness types},
inspired by the programming language Clean, which provide a way to
statically check the number of references to a given array.  The
benefit of this is that if it can be statically proven that an array
only has a single reference, we can safely update it in-place without
violating referential transparency.  A non-unique variable can only be
\textit{observed} - that is, we read its value.  A unique variable can
also be \textit{consumed}, meaning that it becomes inaccessible
afterwards.

Uniqueness typing depends critically on being able to determine
sharing between different variables, so we will start out describing
the sharing analysis performed by the L0 compiler.

\subsection{Sharing analysis}
\label{subsec:l0-sharing}

Whenever the memory regions for two values overlap, we say that they
are \textit{aliased}, or that \textit{sharing} is present.  As an
example, if you have a two-dimensional array \texttt{a} and extract
its first row as the one-dimensional array \texttt{b}, we say that
\texttt{a} and \texttt{b} are aliased.  While the L0 compiler may do a
deep copy if it wishes, it is not required, and this operation thus
holds the potential for sharing memory.  Sharing analysis is
necessarily conservative, and merely imposes an upper bound on the
amount of sharing happening at runtime.  The sharing analysis in L0
has been carefully designed to make the bound as tight as possible,
but still easily computable.

In L0, the only values that can have any sharing are arrays -
everything else is considered ``primitive''.  Tuples are special, in
that they are not considered to have any identity beyond their
elements.  Therefore, when we store sharing information for a tuple,
we do it for each of its elements, rather than the tuple value as a
whole.

To be precise, sharing information for an expression $e$, written
$\aliases{e}$, can take one of two forms:

\begin{enumerate}
\item $l$, where $l$ is a subset of the variables in scope at $e$.
  This means that $e$ may share data with some of the variables in
  $l$.

\item $\langle s_{1}, \ldots, s_{n} \rangle$, which requires that the
  type of $e$ is a tuple $(e_{1}, \ldots, s_{n})$, and denotes that
  $\aliases{e_{i}} = s_{i}$.
\end{enumerate}

We need a way to combine sharing information.  The typical case is for
computing sharing information for the expression \texttt{if c then e1
  else e2}.  Define the associative, commutative operation $s_{1}
\oplus s_{2}$ by the following equation.

\begin{align*}
  l_{1} \oplus l_{2} &= l_{1} \cup l_{2} \\
  l \oplus \langle s_{1}, \ldots, s_{n} \rangle &= \langle l \oplus s_1, \ldots, l \oplus s_n \rangle \\
   \langle s_{1}, \ldots, s_{n} \rangle \oplus l &= \langle l \oplus s_1, \ldots, l \oplus s_n \rangle \\
  \langle s_{1}, \ldots, s_{n} \rangle \oplus \langle s_{n+1}, \ldots, s_{2n} \rangle &= \langle s_{1} \oplus s_{n+1}, \ldots, s_{n} \oplus s_{2n} \rangle \\
\end{align*}

Now $\aliases{\texttt{if c then e1 else e2}} = \aliases{\texttt{e1}}
\oplus \aliases{\texttt{e2}}$.  Note that $(\oplus, \emptyset)$
constitutes a monoid - this is exploited in the L0 compiler.  We will
often treat sharing information as a set and write things such as
$\forall v\in\aliases{e}.p$ -- in these cases, the set elements are
all variables mentioned anywhere in the sharing information.

Aliasing is reflexive -- if $v\in\aliases{e}$, then $\exists
v'\in\aliases{e}\Rightarrow v\in\aliases{v}$.  Aliasing is mostly
intuitive, but here's a few rules describing how sharing is
propagated by various expressions.

\begin{align*}
  \aliases{\texttt{\textit{e}}} &= \emptyset & (\text{Whenever $e$ has a basic type}) \\
  \aliases{\texttt{copy(\textit{e})}} &= \emptyset \\
  \aliases{\texttt{if \textit{c} then ${e}_{1}$ else ${e}_{2}$}} &= \aliases{e_{1}} \oplus \aliases{e_{2}} \\
  \aliases{\textit{f}(e_{1}, \ldots, e_{n})} &= \aliases{e_{1}} \cup \ldots \cup \aliases{e_{n}}
\end{align*}

Pay particular attention to the case for function application - the
sharing analysis is here very conservative, and assumes that the
return value aliases the set of all aliases of its arguments.  This is
a clear candidate for further improvement in the future.

\subsection{Tracking uniqueness}
\label{subsec:l0-tracking-uniqueness}

If the type of an array is preceded by a single asterisk, it denotes
that the array is unique - that it has only a single reference.  The
source operand to a let-with \textit{must} be unique.  If it is not,
it is reported as a type error.  Let-with and function calls are the
only places in which variable consumption can happen.  As a first
example, let us consider a function that replaces the value at a given
position in an integer array.

\begin{alltt}
  fun *[int] replace(*[int] arr, int i, int x) =
    let arr[i] = x in arr
\end{alltt}

The type of this function expresses the fact that it consumes its
array argument, and also returns a unique array.  This permits
composition - \texttt{replace(replace(a, i1, x), i2, y)} is a valid
application.  Defining \texttt{replace} as
\begin{alltt}
  fun [int] replace2(*[int] arr, int i, int x) =
    let arr[i] = x in arr
\end{alltt}
would still be type correct (a unique array can be used anywhere a
nonunique is expected), but the composition
\texttt{replace2(replace2(a, i1, x), i2, y)} would no longer be well
typed.

Checking that uniqueness invariants are being upheld is far subtler
than normal type checking.  In particular, detailed sharing analysis
has to be performed, in order to ensure that after an array $a$ is
modified, it becomes an error to use any value that may refer to
(parts of) the old value of the array.  Whenever we consume a variable
$a$, we mark as inaccessible all of its aliases.

\begin{alltt}
  let b = a in               // Now \(\texttt{b}\in\aliases{\texttt{a}}\).
  let c = a with [i] <- x in // \(\forall{}v\in\aliases{\texttt{a}}\Rightarrow\textrm{Mark \(v\) as consumed.}\)
  b                          // Error, because \(\texttt{b}\in\aliases{\texttt{a}}\)!
\end{alltt}

A key principle is that of \textit{sequence points}, that lexically
delimit the uses of variables.  As an exampe, assume that we are given
a function \texttt{f} of type \texttt{*[int] -> int}.  That is,
\texttt{f} consumes an array and returns an integer.  The expression
\begin{alltt}
  f(a) + a[i]
\end{alltt}
is invalid because a consumption and observation of the same variable
happens within the same \textit{sequence}.  It is valid for a sequence
to contain multiple observations of the same variable, but if a
variable is consumed, that must be the only occurence of the variable
(or any of its aliases) within the sequence.  Binding constructs
(lets, let-withs and loops) create sequence points that delimit
sequences.  If we rewrite the expression to cordon the consumption
into its own sequence, all will be well.
\begin{alltt}
  let c = a[i] // Since a[i] is of primitive type,
               // c does not alias a.
  in f(a) + c
\end{alltt}

The reason for this rule is to enable simpler code generation, as any
necessary order of operations is evident in the code.  It does require
a certain amount of care when doing program transformations, as for
example copy propagation may result in invalid programs.

In the previous examples, function arguments that were consumed were
all simple variables, making it easy to describe what was being
consumed.  But in general, we might have an expression
\begin{alltt}
  replace(e, i, x)
\end{alltt}
where \texttt{e} is some arbitrary expression.  In this case, we mark
as consumed all variables in $\aliases{\texttt{e}}$.

Constant, literal arrays are not considered unique, as the compiler
may put them in read-only memory and return the same reference every
time they are accessed.  For example, the following program is
invalid.
\begin{alltt}
  fun [int] fibs(int i, int x) =
    let a = \{1, 1, 2, 3, 5, 8, 13\} in
    let a[i] = x in a
\end{alltt}
Since \texttt{a} is not unique, its use in the let-with is a type
error.  However, we can use \texttt{copy} to create a unique duplicate
of the array.
\begin{alltt}
  fun [int] fibs(int i, int x) =
    let a = copy(\{1, 1, 2, 3, 5, 8, 13\}) in
    let a[i] = x in a
\end{alltt}

If we have a function such as
\begin{alltt}
  fun int f(*[int] a, int x) = x
\end{alltt}
then it is not valid to curry it in such a way that we provide values
for the consumed parameters.  For example, \texttt{map(f (a), b)}
would be an error.  The reason for this is that \texttt{t} may be
called an unbounded number of times during the mapping, but \texttt{a}
can only be consumed once.


\end{document}

% Some very quick thoughts:

% -- snipets examples for loops with let-with construct, e.g., from
% our benchmarks

% -- show explicitly the equivalence between loop and the recursive
% function

% -- Uniqueness: requires more work. need to think more on this.

%     -- But I would start by introducing aliasing/sharing (very)
%     informally and then giving the uniqueness semantics from the
%     user's perspective.  (Because the discussion gives the feeling
%     the semantics is actually given by the implementation.)  It is
%     not so clear to me what it means when the return type of a
%     function is declared unique.  E.g., `replace(replace(a, i1, x),
%     i2, y)' makes sense but feels like an implementation hack
%     because the slightly modified program below is illegal (and the
%     explanation might give the feeling that it is legal)

%                     let a0 = replace(a, i1, x) in
%                     let b   = a0 in
%                     let a1 = replace(a0, i2, y) in
%                     f(a1, b)

%     I would assume the informal semantics of the
%     unique return type is something like: "on any
%     execution path following the call, it cannot
%     exist a variable defined before the call which
%     aliases the returned expression AND which is
%     used after the call.  The unique types mainly
%     allow a modular implementation, i.e.,
%     intraprocedural analysis. E.g., for the unique
%     result type, the alias for a0 at the first call
%     site is empty, and becomes {b} at the second
%     call site. It follows that an error is
%     discovered at last line since the unique formal
%     argument of replace requires that no variables
%     aliased with the actual-arg expression can be
%     used after the call."

%     Not sure that I like the uniqueness for constant array literals,
%     but that is less important.

%     -- After the consistent informal/semantics section you give the
%     complete story: try to synthesize the full implementation (i
%     don't think you can separate aliasing from unique types as the
%     unique types are mainly a device to simplify aliasing analysis
%     in our case).  So why not give a case-base analysis of how the
%     aliasing info is built.  Then maybe you manage to formalize it,
%     i.e., proof that the check is a sufficient condition for the
%     defined semantics to hold.
