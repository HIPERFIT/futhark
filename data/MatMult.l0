fun   int    redplus1( [int]  a) = reduce(op +, 0, a)
fun  [int]   redplus2([[int]] a) = map   (redplus1, a)

fun  [int]   mul1( [int]  a,  [int]  b) = zipWith(op *, a, b)
fun [[int]]  mul2([[int]] a, [[int]] b) = zipWith(mul1, a, b)

fun [[int]]  replin(int N, [int] a) = replicate(N, a)

fun [[int]] matmultFun(int N, [[int]] a, [[int]] b ) =
    let br  = replicate( N, transpose(b) ) in
    let ar  = map      ( replin(N),    a ) in
    let abr = zipWith  (mul2, ar, br)      in
        map(redplus2, abr) 

fun [[int]] matmultImp(int N, [[int]] a, [[int]] b) =
    let res = replicate(N, iota(N)) in
    for i < N do
        for j < N do
            let partsum = 
                let res = 0 in
                for k < N do
                    let res = res + a[i,k] * b[k,j]
                    in  res
                merge res
            in let res[i,j] = partsum in res
//          in let res' = res with [i,j] <- partsum in res'
        merge res
    merge res


fun ([[int]]*[[int]]) main() = 
    let x = { {1,2}, {3,4} } in 
    let y = { {5,6}, {7,8} } in
        (matmultFun(2, x, y), matmultImp(2, x,y) ) 
