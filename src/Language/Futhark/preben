diff --git a/src/Language/Futhark/Syntax.hs b/src/Language/Futhark/Syntax.hs
index 0091f4d..e3f4e51 100644
--- a/src/Language/Futhark/Syntax.hs
+++ b/src/Language/Futhark/Syntax.hs
@@ -17,6 +17,7 @@ module Language.Futhark.Syntax
   , ShapeDecl (..)
   , Rank (..)
   , TypeBase(..)
+  , UserType (..)
   , TupleArrayElemTypeBase(..)
   , ArrayTypeBase(..)
   , CompTypeBase
@@ -150,6 +151,13 @@ data TupleArrayElemTypeBase shape as vn =
   | TupleArrayElem [TupleArrayElemTypeBase shape as vn]
   deriving (Show)
 
+data UserTupleArrayElemTypeBase shape as vn =
+    UserPrimArrayElem PrimType (as vn)
+  | UserTypeAliasArrayElem Name
+  | UserArrayArrayElem (UserArrayTypeBase shape as vn)
+  | UserTupleArrayElem [UserTupleArrayElemTypeBase shape as vn]
+  deriving (Show)
+
 instance Eq (shape vn) =>
          Eq (TupleArrayElemTypeBase shape as vn) where
   PrimArrayElem bt1 _ == PrimArrayElem bt2 _ = bt1 == bt2
@@ -157,6 +165,13 @@ instance Eq (shape vn) =>
   TupleArrayElem ts1   == TupleArrayElem ts2   = ts1 == ts2
   _                    == _                    = False
 
+instance Eq (shape vn) =>
+         Eq (UserTupleArrayElemTypeBase shape as vn) where
+  UserPrimArrayElem bt1 _ == UserPrimArrayElem bt2 _ = bt1 == bt2
+  UserArrayArrayElem at1   == UserArrayArrayElem at2   = at1 == at2
+  UserTupleArrayElem ts1   == UserTupleArrayElem ts2   = ts1 == ts2
+  _                    == _                    = False
+
 instance Ord (shape vn) =>
          Ord (TupleArrayElemTypeBase shape as vn) where
   PrimArrayElem bt1 _ `compare` PrimArrayElem bt2 _ = bt1 `compare` bt2
@@ -169,6 +184,18 @@ instance Ord (shape vn) =>
   TupleArrayElem {}    `compare` PrimArrayElem {}    = GT
   TupleArrayElem {}    `compare` ArrayArrayElem {}    = GT
 
+instance Ord (shape vn) =>
+         Ord (UserTupleArrayElemTypeBase shape as vn) where
+  UserPrimArrayElem bt1 _ `compare` UserPrimArrayElem bt2 _ = bt1 `compare` bt2
+  UserArrayArrayElem at1   `compare` UserArrayArrayElem at2   = at1 `compare` at2
+  UserTupleArrayElem ts1   `compare` UserTupleArrayElem ts2   = ts1 `compare` ts2
+  UserPrimArrayElem {}    `compare` UserArrayArrayElem {}    = LT
+  UserPrimArrayElem {}    `compare` UserTupleArrayElem {}    = LT
+  UserArrayArrayElem {}    `compare` UserTupleArrayElem {}    = LT
+  UserArrayArrayElem {}    `compare` UserPrimArrayElem {}    = GT
+  UserTupleArrayElem {}    `compare` UserPrimArrayElem {}    = GT
+  UserTupleArrayElem {}    `compare` UserArrayArrayElem {}    = GT
+
 -- | An array type.
 data ArrayTypeBase shape as vn =
     PrimArray PrimType (shape vn) Uniqueness (as vn)
@@ -186,6 +213,15 @@ instance Eq (shape vn) =>
   _ == _ =
     False
 
+instance Eq (shape vn) =>
+         Eq (UserArrayTypeBase shape as vn) where
+  UserPrimArray et1 dims1 u1 _ == UserPrimArray et2 dims2 u2 _ =
+    et1 == et2 && dims1 == dims2 && u1 == u2
+  UserTupleArray ts1 dims1 u1 == UserTupleArray ts2 dims2 u2 =
+    ts1 == ts2 && dims1 == dims2 && u1 == u2
+  _ == _ =
+    False
+
 instance Ord (shape vn) =>
          Ord (ArrayTypeBase shape as vn) where
   PrimArray et1 dims1 u1 _ <= PrimArray et2 dims2 u2 _
@@ -209,6 +245,43 @@ instance Ord (shape vn) =>
   TupleArray {} <= PrimArray {} =
     False
 
+
+instance Ord (shape vn) =>
+         Ord (UserArrayTypeBase shape as vn) where
+  UserPrimArray et1 dims1 u1 _ <= UserPrimArray et2 dims2 u2 _
+    | et1 < et2     = True
+    | et1 > et2     = False
+    | dims1 < dims2 = True
+    | dims1 > dims2 = False
+    | u1 < u2       = True
+    | u1 > u2       = False
+    | otherwise     = True
+  UserTupleArray ts1 dims1 u1 <= UserTupleArray ts2 dims2 u2
+    | ts1 < ts2     = True
+    | ts1 > ts2     = False
+    | dims1 < dims2 = True
+    | dims1 > dims2 = False
+    | u1 < u2       = True
+    | u1 > u2       = False
+    | otherwise     = True
+-- | I am not sure what the reason behind these evaluations are.
+  UserTypeAliasArray {} <= UserTypeAliasArray {} =
+    False
+
+  UserPrimArray {} <= UserTupleArray {} =
+    True
+  UserTupleArray {} <= UserPrimArray {} =
+    False
+-- | So far I am considering TypeAlias arrays as 
+  UserTypeAliasArray {} <= UserTupleArray {} =
+    False
+  UserTupleArray {} <= UserTypeAliasArray {} =
+    False
+    
+  UserTypeAliasArray {} <= UserPrimArray {} =
+    False
+  UserPrimArray {} <= UserTypeAliasArray {} =
+    False
 -- | An Futhark type is either an array, a prim type, or a tuple.
 -- When comparing types for equality with '==', aliases are ignored,
 -- but dimensions much match.
@@ -217,13 +290,32 @@ data TypeBase shape as vn = Prim PrimType
                           | Tuple [TypeBase shape as vn]
                           deriving (Eq, Ord, Show)
 
+
 -- | A type with aliasing information and no shape annotations, used
 -- for describing the type of a computation.
 type CompTypeBase = TypeBase Rank Names
 
 -- | A type with shape annotations and no aliasing information, used
 -- for declarations.
-type DeclTypeBase = TypeBase ShapeDecl NoInfo
+
+-- || type DeclTypeBase = TypeBase ShapeDecl NoInfo
+
+data UserType shape as vn = UserPrim PrimType
+                          | UserArray (UserArrayTypeBase shape as vn)
+                          | UserTuple [UserType shape as vn]
+                          | UserTypeAlias Name
+  deriving (Eq, Ord, Show)
+-- | An array type.
+data UserArrayTypeBase shape as vn =
+    UserPrimArray PrimType (shape vn) Uniqueness (as vn)
+    -- ^ An array whose elements are primitive types.
+  | UserTypeAliasArray Name (shape vn) Uniqueness (as vn)
+    -- ^ An array whose elements are primitive types.
+  | UserTupleArray [UserTupleArrayElemTypeBase shape as vn] (shape vn) Uniqueness
+    -- ^ An array whose elements are tuples.
+    deriving (Show)
+
+type DeclTypeBase = UserType ShapeDecl NoInfo
 
 -- | An array type with shape annotations and no aliasing information,
 -- used for declarations.
@@ -544,19 +636,31 @@ instance Located (PatternBase ty vn) where
 
 -- | Function Declarations
 type FunDecBase ty vn = (Name,
-                         DeclTypeBase vn,
-                         [ParamBase vn],
-                         ExpBase ty vn,
+                         DeclTypeBase vn, -- returtypen
+                         [ParamBase vn], -- parametrenes variabel-navne
+                         ExpBase ty vn, -- Expressions
                          SrcLoc)
 
+-- | Type Declarations
+type TypeDec ty vn = ( Name -- Den selverklÃ¦rede types navn
+                     , DeclTypeBase vn -- type-definitionen
+                     , SrcLoc
+                     )
+
+data DecBase ty vn = FunDecBase ty vn
+                   | TypeDec ty vn
+  deriving (Show)
+
 -- | An entire Futhark program.
-newtype ProgBase ty vn = Prog { progFunctions :: [FunDecBase ty vn] }
+-- | newtype ProgBase ty vn = Prog { progFunctions :: [DecBase ty vn] }
+newtype ProgBase ty vn = Prog { progDeclarations :: [DecBase ty vn] }
   deriving (Show)
 
 -- | An entire Futhark program, including headers.
 data ProgBaseWithHeaders ty vn =
   ProgWithHeaders { progWHHeaders :: [ProgHeader]
-                  , progWHFunctions :: [FunDecBase ty vn]
+--                  , progWHFunctions :: [FunDecBase ty vn]
+                  , progWHDeclarations :: [DecBase ty vn]
                   }
   deriving (Show)
 
